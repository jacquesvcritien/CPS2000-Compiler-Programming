<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment1</a> &gt; <a href="index.source.html" class="el_package">parser</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">package parser;

import exceptions.InvalidSyntaxException;
import lexer.Lexer;
import lexer.Token;
import lexer.TypeToken;
import parser.node.*;

import java.io.IOException;
import java.util.ArrayList;

/**
 * Class for parser
 */
public class Parser {
    //lexer to use
    Lexer lexer;
    //holds the current token
    Token currentToken;

    /**
     * Constructor
     * @param lexer lexer to use
     * @throws IOException
     * @throws InvalidSyntaxException
     */
<span class="fc" id="L27">    public Parser(Lexer lexer) throws IOException, InvalidSyntaxException {</span>
<span class="fc" id="L28">        this.lexer = lexer;</span>
        //se current token by getting
<span class="fc" id="L30">        this.currentToken = this.lexer.nextToken();</span>
<span class="fc" id="L31">    }</span>

    /**
     * Method to check if the current token is of the correct type
     * @param typeToken exprected token
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private void absorb(TypeToken typeToken) throws IOException, InvalidSyntaxException {
        /*
         compare current token's type with the type passed and if they match,
         absorb the token. Otherwise throw an error
         */
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if(typeToken == this.currentToken.getType())</span>
<span class="fc" id="L45">            this.currentToken = this.lexer.nextToken();</span>
        else
<span class="fc" id="L47">            throw new InvalidSyntaxException(&quot;LINE &quot;+lexer.getCurrentLine()+&quot;: Syntax is invalid - Expected &quot;+typeToken);</span>
<span class="fc" id="L48">    }</span>

    /**
     * Method for literal
     * &lt;INTEGERLITERAL&gt; | &lt;FLOATLITERAL&gt; | &lt;BOOLLITERAL&gt;
     * @return an Expression
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression literal() throws IOException, InvalidSyntaxException {
        //get current token
<span class="fc" id="L59">        Token token = this.currentToken;</span>

        //check type of current token
<span class="fc bfc" id="L62" title="All 3 branches covered.">        switch(token.getType()) {</span>
            //if literal
            case INTEGER_LITERAL: {
<span class="fc" id="L65">                absorb(TypeToken.INTEGER_LITERAL);</span>
<span class="fc" id="L66">                return new ASTIntegerLiteral(token);</span>
            }
            //if float
            case FLOAT_LITERAL: {
<span class="fc" id="L70">                absorb(TypeToken.FLOAT_LITERAL);</span>
<span class="fc" id="L71">                return new ASTFloatLiteral(token);</span>
            }
            //if boolean
            default: {
<span class="fc" id="L75">                absorb(TypeToken.BOOLEAN_LITERAL);</span>
<span class="fc" id="L76">                return new ASTBooleanLiteral(token);</span>
            }
        }
    }

    /**
     * Method to parse an identifier
     * ( '_' | &lt;LETTER&gt; ) { '_' | &lt;LETTER&gt; | &lt;DIGIT&gt;}
     * @return identifier node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTIdentifier identifier() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L90">        Token identifier = this.currentToken;</span>
        //check it
<span class="fc" id="L92">        absorb(TypeToken.IDENTIFIER);</span>

        //return new identifier token
<span class="fc" id="L95">        return new ASTIdentifier(identifier.getAttribute());</span>
    }

    /**
     * Method to check type
     * 'float' | 'int' | 'bool'
     * @return Token
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private Token type() throws IOException, InvalidSyntaxException {
        //get current token
<span class="fc" id="L107">        Token token = this.currentToken;</span>

        //check if the token is a type token
<span class="fc" id="L110">        absorb(TypeToken.TYPE);</span>
<span class="fc" id="L111">        return token;</span>
    }

    /**
     * Method to check for expressions
     * can be : LITERAL, IDENTIFIER, FUNCTIONCALL, SUBEXPRESSION, UNARY
     * @return
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression factor() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L123">        Token token = this.currentToken;</span>

        //check type of current token
<span class="fc bfc" id="L126" title="All 4 branches covered.">        switch(token.getType())</span>
        {
            //literal
            case INTEGER_LITERAL:
            case FLOAT_LITERAL:
            case BOOLEAN_LITERAL:
            {
<span class="fc" id="L133">                return literal();</span>
            }
            //identifier
            case IDENTIFIER:
            {
                //get identifier
<span class="fc" id="L139">                ASTIdentifier identifier = identifier();</span>
                //if it is does not have an open bracket(it must be an identifier)
<span class="fc bfc" id="L141" title="All 2 branches covered.">                if(this.currentToken.getType() != TypeToken.BRACKET_OPEN)</span>
<span class="fc" id="L142">                    return identifier;</span>
                //else its a functioncall
                else
<span class="fc" id="L145">                    return functionCall(identifier);</span>
            }
            //subexpression
            case BRACKET_OPEN:
            {
<span class="fc" id="L150">                return subExpression();</span>
            }
            //unary - not
            //unary - '-'
            default:
            {
<span class="fc" id="L156">                return unary();</span>
            }

        }
    }

    /**
     * Method for term
     * &lt;FACTOR&gt; {&lt;MULTIPLICATIVE OP (*, \, and)&gt;} &lt;FACTOR&gt;
     * @return an expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression term() throws IOException, InvalidSyntaxException{
        // get factor
<span class="fc" id="L171">        ASTExpression node = factor();</span>

        // while the current token is a multiplicative operand
<span class="fc bfc" id="L174" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.MULTIPLICATIVE_OP)</span>
        {
            //get current token
<span class="fc" id="L177">            Token token = this.currentToken;</span>
            //check the multiplicative op type (absorb it)
<span class="fc" id="L179">            absorb(TypeToken.MULTIPLICATIVE_OP);</span>

            //get the right factor
<span class="fc" id="L182">            ASTExpression right = factor();</span>
            //get operand
<span class="fc" id="L184">            String operand = token.getAttribute();</span>
            //create a node with left, right and operand
<span class="fc" id="L186">            node = new ASTBinExpression(node, operand, right);</span>
<span class="fc" id="L187">        }</span>

        //return node
<span class="fc" id="L190">        return node;</span>

    }

    /**
     * Method for sub expression
     * '(' &lt;EXPRESSION&gt; ')'
     * @return an Expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression subExpression() throws IOException, InvalidSyntaxException{

        //make sure the first token is an open bracket
<span class="fc" id="L204">        absorb(TypeToken.BRACKET_OPEN);</span>
        //check the expression
<span class="fc" id="L206">        ASTExpression node = simpleExpression();</span>
        //make sure there is the ending closing bracket
<span class="fc" id="L208">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //return the node returned from expression
<span class="fc" id="L210">        return node;</span>

    }


    /**
     * Method for actual params
     * &lt;EXPRESSION&gt; { ',' &lt;EXPRESSION&gt; }
     * @return an actual params node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTActualParams actualParams() throws IOException, InvalidSyntaxException{
        //create a list of expressions
<span class="fc" id="L224">        ArrayList&lt;ASTExpression&gt; expressions = new ArrayList&lt;ASTExpression&gt;();</span>
        //check the expression and add it to the list
<span class="fc" id="L226">        expressions.add(expression());</span>

        //while there is more commas (more expressions)
<span class="fc bfc" id="L229" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.COMMA)</span>
        {
            //absorb the comme
<span class="fc" id="L232">            absorb(TypeToken.COMMA);</span>

            //get the next expression and add it to the list
<span class="fc" id="L235">            ASTExpression newExpression = expression();</span>
<span class="fc" id="L236">            expressions.add(newExpression);</span>
<span class="fc" id="L237">        }</span>

        //return the actual params node with the expressions
<span class="fc" id="L240">        return new ASTActualParams(expressions);</span>

    }

    /**
     * Method for functionCall
     * &lt;IDENTIFIER&gt; '(' [&lt;ACTUALPARAMS&gt;] ')'
     * @param identifier identifier of the function call
     * @return function call node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFunctionCall functionCall(ASTIdentifier identifier) throws IOException, InvalidSyntaxException{

        //absorb the opening bracket
<span class="fc" id="L255">        absorb(TypeToken.BRACKET_OPEN);</span>

        //if the next is a closing bracket, return an empty actual params node, else get the actual params
<span class="fc bfc" id="L258" title="All 2 branches covered.">        ASTActualParams actualParamsNode = (this.currentToken.getType() != TypeToken.BRACKET_CLOSE) ? actualParams() : new ASTActualParams();</span>

        //absorb the closing bracker
<span class="fc" id="L261">        absorb(TypeToken.BRACKET_CLOSE);</span>

        //return new function call node with actual params and identifier
<span class="fc" id="L264">        return new ASTFunctionCall(identifier, actualParamsNode);</span>
    }

    /**
     * Method for assignment
     * &lt;IDENTIFIER&gt; '=' &lt;EXPRESSION&gt;
     * @return an assignment node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTAssignment assignment() throws IOException, InvalidSyntaxException{

        //if the current token is not an identifier (in case of empty assignment in for loop), return empty assignment
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if((currentToken.getType()!= TypeToken.IDENTIFIER))</span>
<span class="fc" id="L278">            return new ASTAssignment();</span>

        //get identifier
<span class="fc" id="L281">        ASTIdentifier identifier = identifier();</span>
        //absorb equal sign
<span class="fc" id="L283">        absorb(TypeToken.EQUAL_SIGN);</span>
        //get expression
<span class="fc" id="L285">        ASTExpression expression = expression();</span>


        //create assignment node with identifier and expression
<span class="fc" id="L289">        return new ASTAssignment(identifier, expression);</span>
    }

    /**
     * Method for variable declaration
     * 'let' &lt;IDENTIFIER&gt; ':' ( &lt;TYPE&gt; | &lt;AUTO&gt; ) '=' &lt;EXPRESSION&gt;
     * @return a variable declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTVariableDecl variableDeclaration() throws IOException, InvalidSyntaxException{

        //if the current token is not a LET (in case of empty variable declaration in for loop), return empty variable declaration
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if(currentToken.getType()!= TypeToken.LET)</span>
<span class="fc" id="L303">            return new ASTVariableDecl();</span>

        //absorb let
<span class="fc" id="L306">        absorb(TypeToken.LET);</span>
        //get identifier
<span class="fc" id="L308">        ASTIdentifier identifier = identifier();</span>
        //absorb colon
<span class="fc" id="L310">        absorb(TypeToken.COLON);</span>

        //get current token
<span class="fc" id="L313">        Token type = this.currentToken;</span>

        //absorv type
<span class="fc bfc" id="L316" title="All 2 branches covered.">        switch(type.getType())</span>
        {
<span class="fc" id="L318">            case TYPE: absorb(TypeToken.TYPE);break;</span>
<span class="fc" id="L319">            default: absorb(TypeToken.AUTO);break; //auto</span>
        }

        //set type
<span class="fc" id="L323">        identifier.setType(type.getAttribute());</span>
        //absorb equal sign
<span class="fc" id="L325">        absorb(TypeToken.EQUAL_SIGN);</span>
        //get expression
<span class="fc" id="L327">        ASTExpression expression = expression();</span>

        //return variable declaration node with identifier and expression
<span class="fc" id="L330">        return new ASTVariableDecl(identifier, expression);</span>
    }

    /**
     * Method for formal params
     * &lt;IDENTIFIER&gt; ':' &lt;TYPE&gt;
     * @return formal param node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFormalParam formalParam() throws IOException, InvalidSyntaxException{
        //get identifier
<span class="fc" id="L342">        ASTIdentifier identifier = identifier();</span>
        //absorb colon
<span class="fc" id="L344">        absorb(TypeToken.COLON);</span>
        //get type
<span class="fc" id="L346">        Token type = type();</span>
        //set identifier type to actual type from type got (int, float, bool or auto)
<span class="fc" id="L348">        identifier.setType(type.getAttribute());</span>

        //return new ast formal param with identifier
<span class="fc" id="L351">        return new ASTFormalParam(identifier);</span>
    }

    /**
     * Method for for formal params
     * &lt;FORMALPARAM&gt; { ',' &lt;FORMALPARAM&gt;}
     * @return formal params node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFormalParams formalParams() throws IOException, InvalidSyntaxException{
        //init list to hold params
<span class="fc" id="L363">        ArrayList&lt;ASTFormalParam&gt; params = new ArrayList&lt;ASTFormalParam&gt;();</span>

        //if current token is close bracket, it means there is no params
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if(this.currentToken.getType() == TypeToken.BRACKET_CLOSE)</span>
<span class="fc" id="L367">            return new ASTFormalParams(params);</span>

        //else, get formal param and add it to the list
<span class="fc" id="L370">        params.add(formalParam());</span>

        //while there is a comma (more params)
<span class="fc bfc" id="L373" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.COMMA)</span>
        {

            //absorb the comma
<span class="fc" id="L377">            absorb(TypeToken.COMMA);</span>

            //get param and add it to the list
<span class="fc" id="L380">            ASTFormalParam newParam = formalParam();</span>
<span class="fc" id="L381">            params.add(newParam);</span>
<span class="fc" id="L382">        }</span>

        //return new formal params node with params
<span class="fc" id="L385">        return new ASTFormalParams(params);</span>
    }

    /**
     * Method for function declaration
     * 'ff' &lt;IDENTIFIER&gt; '(' [&lt;FORMALPARAMS&gt;] ')' ':' (&lt;TYPE&gt; | &lt;AUTO&gt;) &lt;BLOCK&gt;
     * @return function declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFunctionDecl functionDeclaration() throws IOException, InvalidSyntaxException{
        //absorb ff
<span class="fc" id="L397">        absorb(TypeToken.FF);</span>
        //get identifier
<span class="fc" id="L399">        ASTIdentifier identifier = identifier();</span>
        //absorb open bracker
<span class="fc" id="L401">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get formal params
<span class="fc" id="L403">        ASTFormalParams formalParamsNode = formalParams();</span>
        //absorb closing bracket
<span class="fc" id="L405">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //absorb colon
<span class="fc" id="L407">        absorb(TypeToken.COLON);</span>

<span class="fc" id="L409">        Token type = this.currentToken;</span>
        //absorb type
<span class="fc bfc" id="L411" title="All 2 branches covered.">        switch(type.getType())</span>
        {
<span class="fc" id="L413">            case TYPE: absorb(TypeToken.TYPE);break;</span>
<span class="fc" id="L414">            default: absorb(TypeToken.AUTO);break;</span>
        }

        //set identifier's type to attribute of type token (int, float, bool or auto)
<span class="fc" id="L418">        identifier.setType(type.getAttribute());</span>

        //get block
<span class="fc" id="L421">        ASTBlock block = block();</span>

        //return new function declaration node with identifier, formalParamsNode and block
<span class="fc" id="L424">        return new ASTFunctionDecl(identifier, formalParamsNode, block);</span>
    }

    /**
     * Method for print
     * 'print' &lt;EXPRESSION&gt;
     * @return print node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTPrint printStatement() throws IOException, InvalidSyntaxException{
        //absorb print
<span class="fc" id="L436">        absorb(TypeToken.PRINT);</span>
        //get expression
<span class="fc" id="L438">        ASTExpression expression = expression();</span>
<span class="fc" id="L439">        return new ASTPrint( expression);</span>
    }

    /**
     * Method for return
     * 'return' &lt;EXPRESSION&gt;
     * @return return node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTReturn returnStatement() throws IOException, InvalidSyntaxException{
        //get return
<span class="fc" id="L451">        absorb(TypeToken.RETURN);</span>
        //get expression
<span class="fc" id="L453">        ASTExpression expression = expression();</span>
<span class="fc" id="L454">        return new ASTReturn(expression);</span>
    }

    /**
     * Method for unary
     * ( '-' | 'not' ) &lt;EXPRESSION&gt;
     * @return unary node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTUnary unary() throws IOException, InvalidSyntaxException{

        //get current token
<span class="fc" id="L467">        Token token = this.currentToken;</span>
        //get type of token
<span class="fc bfc" id="L469" title="All 2 branches covered.">        switch(token.getType())</span>
        {
<span class="fc" id="L471">            case ADDITIVE_OP: absorb(TypeToken.ADDITIVE_OP);break; // case of '-'</span>
<span class="fc" id="L472">            default: absorb(TypeToken.NOT);break; // case of '-'</span>
        }

<span class="fc" id="L475">        return new ASTUnary(token.getAttribute(), expression());</span>
    }

    /**
     * Method for simple expression
     * &lt;TERM&gt; {&lt;ADDITIVEOP( +, -, 'or')&gt; &lt;TERM&gt;}
     * @return an expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression simpleExpression() throws IOException, InvalidSyntaxException{
        //get term
<span class="fc" id="L487">        ASTExpression node = term();</span>

        //while there is an additive op
<span class="fc bfc" id="L490" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.ADDITIVE_OP)</span>
        {
            //get current token
<span class="fc" id="L493">            Token token = this.currentToken;</span>
            //absorb the additive operand
<span class="fc" id="L495">            absorb(TypeToken.ADDITIVE_OP);</span>
            //create the bin expr node with term, operand and he right term
<span class="fc" id="L497">            node = new ASTBinExpression(node, token.getAttribute(), term());</span>
<span class="fc" id="L498">        }</span>

        //return node
<span class="fc" id="L501">        return node;</span>

    }

    /**
     * Method for if statement
     * 'if '(' &lt;EXPRESSION&gt; ')' &lt;BLOCK&gt; [ 'else' &lt;BLOCK&gt; ]
     * @return an if node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTIf ifStatement() throws IOException, InvalidSyntaxException{
        //absorb if
<span class="fc" id="L514">        absorb(TypeToken.IF);</span>
        //absorb bracket open
<span class="fc" id="L516">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get expression
<span class="fc" id="L518">        ASTExpression expression = expression();</span>
        //absorb bracket close
<span class="fc" id="L520">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L522">        ASTBlock block = block();</span>

        //init block for else
        ASTBlock elseBlock;
        //if the current token is else, there is an else block
<span class="fc bfc" id="L527" title="All 2 branches covered.">        if(currentToken.getType() == TypeToken.ELSE)</span>
        {
            //absorb else
<span class="fc" id="L530">            absorb(TypeToken.ELSE);</span>
            //get else block
<span class="fc" id="L532">            elseBlock = block();</span>
        }
        //else leave the else block empty
        else
<span class="fc" id="L536">            elseBlock = new ASTBlock();</span>

        //return if node with expression, block and elseblock
<span class="fc" id="L539">        return new ASTIf(expression, block, elseBlock);</span>
    }

    /**
     * Method for for statement
     * 'for; '(' [&lt;VARIABLEDECL&gt;] ';' &lt;EXPRESSION&gt; ';' [&lt;ASSIGNMENT&gt;] ')' &lt;BLOCK&gt;
     * @return for node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFor forStatement() throws IOException, InvalidSyntaxException{
        //absorb for
<span class="fc" id="L551">        absorb(TypeToken.FOR);</span>
        //absorb bracket open
<span class="fc" id="L553">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get variable declaration
<span class="fc" id="L555">        ASTVariableDecl variableDecl = variableDeclaration();</span>
        //absorb semi colon
<span class="fc" id="L557">        absorb(TypeToken.SEMI_COLON);</span>
        //get expression
<span class="fc" id="L559">        ASTExpression expression = expression();</span>
        //absorb semi colon
<span class="fc" id="L561">        absorb(TypeToken.SEMI_COLON);</span>
        //get assignment
<span class="fc" id="L563">        ASTAssignment assignment = assignment();</span>
        //absorb bracket close
<span class="fc" id="L565">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L567">        ASTBlock block = block();</span>

        //return for node with variable declaration, expression, assignment and block
<span class="fc" id="L570">        return new ASTFor(variableDecl, expression, assignment, block);</span>
    }

    /**
     * Method for while
     * 'while' '(' &lt;EXPRESSION&gt; '); &lt;BLOCK&gt;
     * @return while node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTWhile whileStatement() throws IOException, InvalidSyntaxException{
        //absorb while
<span class="fc" id="L582">        absorb(TypeToken.WHILE);</span>
        //absorb bracket open
<span class="fc" id="L584">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get expression
<span class="fc" id="L586">        ASTExpression expression = expression();</span>
        //absorb bracket close
<span class="fc" id="L588">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L590">        ASTBlock block = block();</span>

        //return new while node with expression and block
<span class="fc" id="L593">        return new ASTWhile(expression, block);</span>
    }

    /**
     * Method for expression
     * &lt;SIMPLEEXPR&gt; { &lt;RELATIONALOP(&lt;, &gt;, ==, &lt;&gt;, &lt;=, &gt;=)&gt; &lt;SIMPLEEXPR&gt;}
     * @return expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression expression() throws IOException, InvalidSyntaxException{
        //get simple expression
<span class="fc" id="L605">        ASTExpression node = simpleExpression();</span>

        //while there is a relational op
<span class="fc bfc" id="L608" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.RELATIONAL_OP)</span>
        {
            //get current token
<span class="fc" id="L611">            Token token = this.currentToken;</span>
            //absorb the operand
<span class="fc" id="L613">            absorb(TypeToken.RELATIONAL_OP);</span>

            //set node to binary expression node with left simple expression, operand and right simple expression
<span class="fc" id="L616">            node = new ASTBinExpression(node, token.getAttribute(), simpleExpression());</span>
<span class="fc" id="L617">        }</span>

<span class="fc" id="L619">        return node;</span>
    }

    /**
     * Method for statement
     * &lt;VARIABLEDECL&gt; ';' | &lt;ASSIGNMENT&gt; ';' | &lt;PRINTSTMNT&gt; ';' | &lt;IFSTMNT&gt;  | &lt;FORSTMNT&gt; | &lt;WHILESTMNT&gt;  | &lt;RETURNSTMNT&gt; ';' Z
     * &lt;FUNCTIONDECL&gt; | &lt;BLOCK&gt;
     * @return a statment node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTStatement statement() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L632">        Token token = this.currentToken;</span>
        //init node to return
<span class="fc" id="L634">        ASTStatement toReturn = null;</span>

        //get type
<span class="fc bfc" id="L637" title="All 10 branches covered.">        switch(token.getType())</span>
        {
            //variable declaration
            case LET:
            {
                //get variable declaration
<span class="fc" id="L643">                toReturn = variableDeclaration();</span>
                //absorb semi colon
<span class="fc" id="L645">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L646">            };break;</span>
            case IDENTIFIER:
            {
                //get assignment
<span class="fc" id="L650">                toReturn = assignment();</span>
                //absorb semi colon
<span class="fc" id="L652">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L653">            };break;</span>
            case PRINT:
            {
                //get print
<span class="fc" id="L657">                toReturn = printStatement();</span>
                //absorb semi colon
<span class="fc" id="L659">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L660">            };break;</span>
<span class="fc" id="L661">            case IF: return ifStatement();</span>
<span class="fc" id="L662">            case FOR: return forStatement();</span>
<span class="fc" id="L663">            case WHILE: return whileStatement();</span>
            case RETURN:
            {
                //get return statment
<span class="fc" id="L667">                toReturn = returnStatement();</span>
                //absorb semi colon
<span class="fc" id="L669">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L670">            };break;</span>
<span class="fc" id="L671">            case FF: return functionDeclaration();</span>
<span class="fc" id="L672">            case CURLY_OPEN: return block();</span>
<span class="fc" id="L673">            default: return null;//EOF</span>
        }

        //return statement set
<span class="fc" id="L677">        return toReturn;</span>
    }

    /**
     * Method for block
     * '{' {&lt;STATEMENT&gt;} '}'
     * @return a block node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTBlock block() throws IOException, InvalidSyntaxException{
        //absorb open curly
<span class="fc" id="L689">        absorb(TypeToken.CURLY_OPEN);</span>
        //init list to store statements
<span class="fc" id="L691">        ArrayList&lt;ASTStatement&gt; statements = new ArrayList&lt;ASTStatement&gt;();</span>

        //while it is not an ending curly bracket
<span class="fc bfc" id="L694" title="All 2 branches covered.">        while(this.currentToken.getType() != TypeToken.CURLY_CLOSE)</span>
        {
            //get statement and add to the list
<span class="fc" id="L697">            ASTStatement statement = statement();</span>
<span class="fc" id="L698">            statements.add(statement);</span>
<span class="fc" id="L699">        }</span>

        //absorb closing curly bracket
<span class="fc" id="L702">        absorb(TypeToken.CURLY_CLOSE);</span>

        //return block node with list of statments
<span class="fc" id="L705">        return new ASTBlock(statements);</span>
    }

    /**
     * Method for program
     * { &lt;STATEMENT&gt; }
     * @return return node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTProgram program() throws IOException, InvalidSyntaxException{
        //init list to store statements
<span class="fc" id="L717">        ArrayList&lt;ASTStatement&gt; statements = new ArrayList&lt;ASTStatement&gt;();</span>
        //get statement
<span class="fc" id="L719">        ASTStatement statement = statement();</span>

        //while statement is not null
<span class="fc bfc" id="L722" title="All 2 branches covered.">        while(statement != null)</span>
        {
            //add statement to list and get the next one
<span class="fc" id="L725">            statements.add(statement);</span>
<span class="fc" id="L726">            statement = statement();</span>
        }

        //return new program node with statements
<span class="fc" id="L730">        return new ASTProgram(statements);</span>
    }


    /**
     * Method to start parsing
     * @return a program node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTProgram parse() throws IOException, InvalidSyntaxException{
<span class="fc" id="L741">        return program();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>