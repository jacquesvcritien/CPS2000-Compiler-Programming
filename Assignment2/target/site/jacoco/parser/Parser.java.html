<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment2</a> &gt; <a href="index.source.html" class="el_package">parser</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">package parser;

import exceptions.InvalidSyntaxException;
import lexer.Lexer;
import lexer.Token;
import lexer.TypeToken;
import parser.node.*;
import parser.node.expression.*;
import parser.node.expression.identifier.ASTAbstractIdentifier;
import parser.node.expression.identifier.ASTArrayIdentifier;
import parser.node.expression.identifier.ASTIdentifier;
import parser.node.statement.*;
import parser.node.statement.declaration.ASTArrayDecl;
import parser.node.statement.declaration.ASTDecl;
import parser.node.statement.declaration.ASTVariableDecl;

import java.io.IOException;
import java.util.ArrayList;

/**
 * Class for parser
 */
public class Parser {
    //lexer to use
    Lexer lexer;
    //holds the current token
    Token currentToken;

    /**
     * Constructor
     * @param lexer lexer to use
     * @throws IOException
     * @throws InvalidSyntaxException
     */
<span class="fc" id="L35">    public Parser(Lexer lexer) throws IOException, InvalidSyntaxException {</span>
<span class="fc" id="L36">        this.lexer = lexer;</span>
        //se current token by getting
<span class="fc" id="L38">        this.currentToken = this.lexer.nextToken();</span>
<span class="fc" id="L39">    }</span>

    /**
     * Method to check if the current token is of the correct type
     * @param typeToken exprected token
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private void absorb(TypeToken typeToken) throws IOException, InvalidSyntaxException {
        /*
         compare current token's type with the type passed and if they match,
         absorb the token. Otherwise throw an error
         */
<span class="fc bfc" id="L52" title="All 2 branches covered.">        if(typeToken == this.currentToken.getType())</span>
<span class="fc" id="L53">            this.currentToken = this.lexer.nextToken();</span>
        else
<span class="fc" id="L55">            throw new InvalidSyntaxException(&quot;LINE &quot;+lexer.getCurrentLine()+&quot;: Syntax is invalid - Expected &quot;+typeToken);</span>
<span class="fc" id="L56">    }</span>

    /**
     * Method for literal
     * &lt;INTEGERLITERAL&gt; | &lt;FLOATLITERAL&gt; | &lt;BOOLLITERAL&gt; | &lt;CHARLITERAL&gt;
     * @return an Expression
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression literal() throws IOException, InvalidSyntaxException {
        //get current token
<span class="fc" id="L67">        Token token = this.currentToken;</span>

        //check type of current token
<span class="fc bfc" id="L70" title="All 4 branches covered.">        switch(token.getType()) {</span>
            //if boolean
            case BOOLEAN_LITERAL: {
<span class="fc" id="L73">                absorb(TypeToken.BOOLEAN_LITERAL);</span>
<span class="fc" id="L74">                return new ASTBooleanLiteral(token);</span>
            }
            //if float
            case FLOAT_LITERAL: {
<span class="fc" id="L78">                absorb(TypeToken.FLOAT_LITERAL);</span>
<span class="fc" id="L79">                return new ASTFloatLiteral(token);</span>
            }
            //if character
            case CHARACTER_LITERAL: {
<span class="fc" id="L83">                absorb(TypeToken.CHARACTER_LITERAL);</span>
<span class="fc" id="L84">                return new ASTCharacterLiteral(token);</span>
            }
            //if integer
            default: {
<span class="fc" id="L88">                absorb(TypeToken.INTEGER_LITERAL);</span>
<span class="fc" id="L89">                return new ASTIntegerLiteral(token);</span>
            }
        }
    }

    /**
     * Method to parse an array index
     * '[' &lt;INTEGERLITERAL&gt; ']'
     * @return identifier node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression arraySizeIndex() throws IOException, InvalidSyntaxException{
        //absorb opening square bracket
<span class="fc" id="L103">        absorb(TypeToken.SQUARE_OPEN);</span>

        //get integer literal
<span class="fc" id="L106">        ASTExpression index = literal();</span>

        //absorb closing square bracket
<span class="fc" id="L109">        absorb(TypeToken.SQUARE_CLOSE);</span>

        //return new expression
<span class="fc" id="L112">        return index;</span>
    }

    /**
     * Method to parse an identifier
     * ( '_' | &lt;LETTER&gt; ) { '_' | &lt;LETTER&gt; | &lt;DIGIT&gt;}
     * @return identifier node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTIdentifier identifier() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L124">        Token identifier = this.currentToken;</span>
        //check it
<span class="fc" id="L126">        absorb(TypeToken.IDENTIFIER);</span>
        //return new identifier token
<span class="fc" id="L128">        return new ASTIdentifier(identifier.getAttribute());</span>
    }

    /**
     * Method to parse an identifier
     * &lt;IDENTIFIER&gt; '[' &lt;EXPRESSION&gt; ']'
     * @return array identifier node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTArrayIdentifier arrayIdentifier(ASTIdentifier identifier) throws IOException, InvalidSyntaxException{

        //get size or index
<span class="fc" id="L141">        ASTExpression sizeIndex = arraySizeIndex();</span>

        //return new identifier token
<span class="fc" id="L144">        return new ASTArrayIdentifier(identifier.getName(), sizeIndex);</span>
    }

    /**
     * Method to check type
     * 'float' | 'int' | 'bool'
     * @return Token
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private Token type() throws IOException, InvalidSyntaxException {
        //get current token
<span class="fc" id="L156">        Token token = this.currentToken;</span>

        //check if the token is a type token
<span class="fc" id="L159">        absorb(TypeToken.TYPE);</span>
<span class="fc" id="L160">        return token;</span>
    }

    /**
     * Method to check for expressions
     * can be : LITERAL, IDENTIFIER, FUNCTIONCALL, SUBEXPRESSION, UNARY
     * @return
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression factor() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L172">        Token token = this.currentToken;</span>

        //check type of current token
<span class="fc bfc" id="L175" title="All 4 branches covered.">        switch(token.getType())</span>
        {
            //literal
            case INTEGER_LITERAL:
            case FLOAT_LITERAL:
            case BOOLEAN_LITERAL:
            case CHARACTER_LITERAL:
            {
<span class="fc" id="L183">                return literal();</span>
            }
            //identifier
            case IDENTIFIER:
            {
                //get identifier
<span class="fc" id="L189">                ASTIdentifier identifier = identifier();</span>
                //if it has an open bracket(it must be a function call)
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if(this.currentToken.getType() == TypeToken.BRACKET_OPEN)</span>
<span class="fc" id="L192">                    return functionCall(identifier);</span>
                //else if square open, it must be an array declaration
<span class="fc bfc" id="L194" title="All 2 branches covered.">                else if(this.currentToken.getType() == TypeToken.SQUARE_OPEN)</span>
<span class="fc" id="L195">                    return arrayIdentifier(identifier);</span>
                //else its an identifier
                else
<span class="fc" id="L198">                    return identifier;</span>
            }
            //subexpression
            case BRACKET_OPEN:
            {
<span class="fc" id="L203">                return subExpression();</span>
            }
            //unary - not
            //unary - '-'
            default:
            {
<span class="fc" id="L209">                return unary();</span>
            }

        }
    }

    /**
     * Method for term
     * &lt;FACTOR&gt; {&lt;MULTIPLICATIVE OP (*, \, and)&gt;} &lt;FACTOR&gt;
     * @return an expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression term() throws IOException, InvalidSyntaxException{
        // get factor
<span class="fc" id="L224">        ASTExpression node = factor();</span>

        // while the current token is a multiplicative operand
<span class="fc bfc" id="L227" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.MULTIPLICATIVE_OP)</span>
        {
            //get current token
<span class="fc" id="L230">            Token token = this.currentToken;</span>
            //check the multiplicative op type (absorb it)
<span class="fc" id="L232">            absorb(TypeToken.MULTIPLICATIVE_OP);</span>

            //get the right factor
<span class="fc" id="L235">            ASTExpression right = factor();</span>
            //get operand
<span class="fc" id="L237">            String operand = token.getAttribute();</span>
            //create a node with left, right and operand
<span class="fc" id="L239">            node = new ASTBinExpression(node, operand, right);</span>
<span class="fc" id="L240">        }</span>

        //return node
<span class="fc" id="L243">        return node;</span>

    }

    /**
     * Method for sub expression
     * '(' &lt;EXPRESSION&gt; ')'
     * @return an Expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression subExpression() throws IOException, InvalidSyntaxException{

        //make sure the first token is an open bracket
<span class="fc" id="L257">        absorb(TypeToken.BRACKET_OPEN);</span>
        //check the expression
<span class="fc" id="L259">        ASTExpression node = expression();</span>
        //make sure there is the ending closing bracket
<span class="fc" id="L261">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //return the node returned from expression
<span class="fc" id="L263">        return node;</span>

    }


    /**
     * Method for actual params
     * &lt;EXPRESSION&gt; { ',' &lt;EXPRESSION&gt; }
     * @return an actual params node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTActualParams actualParams() throws IOException, InvalidSyntaxException{
        //create a list of expressions
<span class="fc" id="L277">        ArrayList&lt;ASTExpression&gt; expressions = new ArrayList&lt;ASTExpression&gt;();</span>


        //check the expression and add it to the list
<span class="fc" id="L281">        expressions.add(expression());</span>

        //while there is more commas (more expressions)
<span class="fc bfc" id="L284" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.COMMA)</span>
        {
            //absorb the comme
<span class="fc" id="L287">            absorb(TypeToken.COMMA);</span>

            //get the next expression and add it to the list
<span class="fc" id="L290">            ASTExpression newExpression = expression();</span>
<span class="fc" id="L291">            expressions.add(newExpression);</span>
<span class="fc" id="L292">        }</span>

        //return the actual params node with the expressions
<span class="fc" id="L295">        return new ASTActualParams(expressions);</span>

    }

    /**
     * Method for array value
     * '{' [ &lt;EXPRESSION&gt; { ',' &lt;EXPRESSION&gt; } ] '}'
     * @return an actual params node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTArrayValue arrayValue() throws IOException, InvalidSyntaxException{
        //create a list of expressions
<span class="fc" id="L308">        ArrayList&lt;ASTExpression&gt; values = new ArrayList&lt;ASTExpression&gt;();</span>

        //absorb opening curly
<span class="fc" id="L311">        absorb(TypeToken.CURLY_OPEN);</span>

        //check if next is a curly close
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if(currentToken.getType() == TypeToken.CURLY_CLOSE)</span>
        {
            //absorb curly close
<span class="fc" id="L317">            absorb(TypeToken.CURLY_CLOSE);</span>
<span class="fc" id="L318">            return new ASTArrayValue(values);</span>
        }


        //check the expression and add it to the list
<span class="fc" id="L323">        values.add(expression());</span>

        //while there is more commas (more expressions)
<span class="fc bfc" id="L326" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.COMMA)</span>
        {
            //absorb the comma
<span class="fc" id="L329">            absorb(TypeToken.COMMA);</span>

            //get the next value and add it to the list
<span class="fc" id="L332">            ASTExpression newExpression = expression();</span>
<span class="fc" id="L333">            values.add(newExpression);</span>
<span class="fc" id="L334">        }</span>

        //absorb curly close
<span class="fc" id="L337">        absorb(TypeToken.CURLY_CLOSE);</span>

        //return the array value node with the expressions
<span class="fc" id="L340">        return new ASTArrayValue(values);</span>

    }

    /**
     * Method for functionCall
     * &lt;IDENTIFIER&gt; '(' [&lt;ACTUALPARAMS&gt;] ')'
     * @param identifier identifier of the function call
     * @return function call node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFunctionCall functionCall(ASTIdentifier identifier) throws IOException, InvalidSyntaxException{

        //absorb the opening bracket
<span class="fc" id="L355">        absorb(TypeToken.BRACKET_OPEN);</span>

        //if the next is a closing bracket, return an empty actual params node, else get the actual params
<span class="fc bfc" id="L358" title="All 2 branches covered.">        ASTActualParams actualParamsNode = (this.currentToken.getType() != TypeToken.BRACKET_CLOSE) ? actualParams() : new ASTActualParams();</span>

        //absorb the closing bracket
<span class="fc" id="L361">        absorb(TypeToken.BRACKET_CLOSE);</span>

        //return new function call node with actual params and identifier
<span class="fc" id="L364">        return new ASTFunctionCall(identifier, actualParamsNode);</span>
    }

    /**
     * Method for assignment
     * &lt;IDENTIFIER&gt; '=' &lt;EXPRESSION&gt;
     * @return an assignment node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTAssignment assignment() throws IOException, InvalidSyntaxException{

        //if the current token is not an identifier (in case of empty assignment in for loop), return empty assignment
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if((currentToken.getType()!= TypeToken.IDENTIFIER))</span>
<span class="fc" id="L378">            return new ASTAssignment();</span>

        //get identifier
<span class="fc" id="L381">        ASTAbstractIdentifier identifier = identifier();</span>

        //else if square open, it must be an array declaration
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if(this.currentToken.getType() == TypeToken.SQUARE_OPEN)</span>
<span class="fc" id="L385">            identifier =  arrayIdentifier((ASTIdentifier)identifier);</span>

        //absorb equal sign
<span class="fc" id="L388">        absorb(TypeToken.EQUAL_SIGN);</span>
        //get expression
<span class="fc" id="L390">        ASTExpression expression = expression();</span>


        //create assignment node with identifier and expression
<span class="fc" id="L394">        return new ASTAssignment(identifier, expression);</span>
    }

    /**
     * Method for declaration
     * &lt;VARIABLEDECL&gt; | &lt;ARRAYDECL&gt;
     * @return a variable declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTDecl declaration() throws IOException, InvalidSyntaxException{

        //if the current token is not a LET (in case of empty variable declaration in for loop), return empty variable declaration
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if(currentToken.getType()!= TypeToken.LET)</span>
<span class="fc" id="L408">            return new ASTDecl();</span>

        //absorb let
<span class="fc" id="L411">        absorb(TypeToken.LET);</span>
        //get identifier
<span class="fc" id="L413">        ASTIdentifier identifier = identifier();</span>

        //if current token is an opening square bracket it must be an array declaration
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if(currentToken.getType() == TypeToken.SQUARE_OPEN)</span>
<span class="fc" id="L417">            return arrayDeclaration(identifier);</span>
        //if not an array declaration, it is a variable declaration
        else
<span class="fc" id="L420">            return variableDeclaration(identifier);</span>

    }

    /**
     * Method for variable declaration
     * 'let' &lt;IDENTIFIER&gt; ':' ( &lt;TYPE&gt; | &lt;AUTO&gt; ) '=' &lt;EXPRESSION&gt;
     * @param identifier identifier of for the declaration
     * @return a variable declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTVariableDecl variableDeclaration(ASTIdentifier identifier) throws IOException, InvalidSyntaxException{

        //absorb colon
<span class="fc" id="L435">        absorb(TypeToken.COLON);</span>

        //get current token
<span class="fc" id="L438">        Token type = this.currentToken;</span>

        //absorb type
<span class="fc bfc" id="L441" title="All 2 branches covered.">        switch(type.getType())</span>
        {
<span class="fc" id="L443">            case TYPE: absorb(TypeToken.TYPE);break;</span>
<span class="fc" id="L444">            default: absorb(TypeToken.AUTO);break; //auto</span>
        }

        //set type
<span class="fc" id="L448">        identifier.setType(getTypeEnum(type.getAttribute()));</span>

        //absorb equal sign
<span class="fc" id="L451">        absorb(TypeToken.EQUAL_SIGN);</span>
        //get expression
<span class="fc" id="L453">        ASTExpression expression = expression();</span>

        //return variable declaration node with identifier and expression
<span class="fc" id="L456">        return new ASTVariableDecl(identifier, expression);</span>
    }

    /**
     * Method for array declaration
     * 'let' &lt;IDENTIFIER&gt; &lt;ARRAYINDEX&gt; ':' &lt;TYPE&gt; [ '=' &lt;ARRAYVALUE&gt; ]
     * @param identifier identifier of for the declaration
     * @return a variable declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTArrayDecl arrayDeclaration(ASTIdentifier identifier) throws IOException, InvalidSyntaxException{

        //get array size
<span class="fc" id="L470">        ASTExpression arraySize = arraySizeIndex();</span>

<span class="fc" id="L472">        ASTArrayIdentifier arrayIdentifier = new ASTArrayIdentifier(identifier.getName());</span>
        //absorb colon
<span class="fc" id="L474">        absorb(TypeToken.COLON);</span>

        //get current token
<span class="fc" id="L477">        Token type = this.currentToken;</span>

        //set type
<span class="fc" id="L480">        arrayIdentifier.setType(getTypeEnum(type.getAttribute()));</span>

        //set array size
<span class="fc" id="L483">        arrayIdentifier.setSizeIndex(arraySize);</span>

        //absorb type
<span class="fc" id="L486">        absorb(TypeToken.TYPE);</span>

        ASTArrayValue arrayValue;

        //check if there is an equals, if so, there must be a value
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if(currentToken.getType() == TypeToken.EQUAL_SIGN)</span>
        {
            //absorb equal sign
<span class="fc" id="L494">            absorb(TypeToken.EQUAL_SIGN);</span>
<span class="fc" id="L495">            arrayValue = arrayValue();</span>
        }
        //no value
        else
        {
<span class="fc" id="L500">            arrayValue = new ASTArrayValue();</span>
        }

        //return array declaration node with identifier, size and value
<span class="fc" id="L504">        return new ASTArrayDecl(arrayIdentifier, arrayValue);</span>
    }

    /**
     * Method for formal params
     * ( &lt;IDENTIFIER&gt; | &lt;ARRAYIDENTIFIER&gt; )  [ '[' ']' ] ':' &lt;TYPE&gt;
     * @return formal param node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFormalParam formalParam() throws IOException, InvalidSyntaxException{
        //get identifier
<span class="fc" id="L516">        ASTAbstractIdentifier identifier = identifier();</span>

        //check if it is an array type
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if(this.currentToken.getType() == TypeToken.SQUARE_OPEN)</span>
        {
            //absorb open square
<span class="fc" id="L522">            absorb(TypeToken.SQUARE_OPEN);</span>
            //absorb closing
<span class="fc" id="L524">            absorb(TypeToken.SQUARE_CLOSE);</span>
            //set identifier as an array identifier
<span class="fc" id="L526">            identifier = new ASTArrayIdentifier(identifier.getName());</span>
        }

        //absorb colon
<span class="fc" id="L530">        absorb(TypeToken.COLON);</span>
        //get type
<span class="fc" id="L532">        Token type = type();</span>

        //set identifier type to actual type from type got (int, float, bool or auto)
<span class="fc" id="L535">        identifier.setType(getTypeEnum(type.getAttribute()));</span>

        //return new ast formal param with identifier
<span class="fc" id="L538">        return new ASTFormalParam(identifier);</span>
    }

    /**
     * Method for for formal params
     * &lt;FORMALPARAM&gt; { ',' &lt;FORMALPARAM&gt;}
     * @return formal params node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFormalParams formalParams() throws IOException, InvalidSyntaxException{
        //init list to hold params
<span class="fc" id="L550">        ArrayList&lt;ASTFormalParam&gt; params = new ArrayList&lt;ASTFormalParam&gt;();</span>

        //if current token is close bracket, it means there is no params
<span class="fc bfc" id="L553" title="All 2 branches covered.">        if(this.currentToken.getType() == TypeToken.BRACKET_CLOSE)</span>
<span class="fc" id="L554">            return new ASTFormalParams(params);</span>

        //else, get formal param and add it to the list
<span class="fc" id="L557">        params.add(formalParam());</span>

        //while there is a comma (more params)
<span class="fc bfc" id="L560" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.COMMA)</span>
        {

            //absorb the comma
<span class="fc" id="L564">            absorb(TypeToken.COMMA);</span>

            //get param and add it to the list
<span class="fc" id="L567">            ASTFormalParam newParam = formalParam();</span>
<span class="fc" id="L568">            params.add(newParam);</span>
<span class="fc" id="L569">        }</span>

        //return new formal params node with params
<span class="fc" id="L572">        return new ASTFormalParams(params);</span>
    }

    /**
     * Method for function declaration
     * 'ff' &lt;IDENTIFIER&gt; '(' [&lt;FORMALPARAMS&gt;] ')' ':' (&lt;TYPE&gt; | &lt;AUTO&gt;) &lt;BLOCK&gt;
     * @return function declaration node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFunctionDecl functionDeclaration() throws IOException, InvalidSyntaxException{
        //absorb ff
<span class="fc" id="L584">        absorb(TypeToken.FF);</span>
        //get identifier
<span class="fc" id="L586">        ASTIdentifier identifier = identifier();</span>
        //absorb open bracker
<span class="fc" id="L588">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get formal params
<span class="fc" id="L590">        ASTFormalParams formalParamsNode = formalParams();</span>
        //absorb closing bracket
<span class="fc" id="L592">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //absorb colon
<span class="fc" id="L594">        absorb(TypeToken.COLON);</span>

<span class="fc" id="L596">        Token type = this.currentToken;</span>
        //absorb type
<span class="fc bfc" id="L598" title="All 2 branches covered.">        switch(type.getType())</span>
        {
<span class="fc" id="L600">            case TYPE: absorb(TypeToken.TYPE);break;</span>
<span class="fc" id="L601">            default: absorb(TypeToken.AUTO);break;</span>
        }

        //set identifier's type to attribute of type token (int, float, bool, char or auto)
<span class="fc" id="L605">        identifier.setType(getTypeEnum(type.getAttribute()));</span>

        //get block
<span class="fc" id="L608">        ASTBlock block = block();</span>

        //return new function declaration node with identifier, formalParamsNode and block
<span class="fc" id="L611">        return new ASTFunctionDecl(identifier, formalParamsNode, block);</span>
    }

    /**
     * Method for print
     * 'print' &lt;EXPRESSION&gt;
     * @return print node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTPrint printStatement() throws IOException, InvalidSyntaxException{
        //absorb print
<span class="fc" id="L623">        absorb(TypeToken.PRINT);</span>
        //get expression
<span class="fc" id="L625">        ASTExpression expression = expression();</span>
<span class="fc" id="L626">        return new ASTPrint( expression);</span>
    }

    /**
     * Method for return
     * 'return' &lt;EXPRESSION&gt;
     * @return return node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTReturn returnStatement() throws IOException, InvalidSyntaxException{
        //get return
<span class="fc" id="L638">        absorb(TypeToken.RETURN);</span>
        //get expression
<span class="fc" id="L640">        ASTExpression expression = expression();</span>
<span class="fc" id="L641">        return new ASTReturn(expression);</span>
    }

    /**
     * Method for unary
     * ( '-' | 'not' ) &lt;EXPRESSION&gt;
     * @return unary node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTUnary unary() throws IOException, InvalidSyntaxException{

        //get current token
<span class="fc" id="L654">        Token token = this.currentToken;</span>
        //get type of token
<span class="fc bfc" id="L656" title="All 2 branches covered.">        switch(token.getType())</span>
        {
<span class="fc" id="L658">            case ADDITIVE_OP: absorb(TypeToken.ADDITIVE_OP);break; // case of '-'</span>
<span class="fc" id="L659">            default: absorb(TypeToken.NOT);break; // case of '-'</span>
        }

<span class="fc" id="L662">        return new ASTUnary(token.getAttribute(), expression());</span>
    }

    /**
     * Method for simple expression
     * &lt;TERM&gt; {&lt;ADDITIVEOP( +, -, 'or')&gt; &lt;TERM&gt;}
     * @return an expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression simpleExpression() throws IOException, InvalidSyntaxException{
        //get term
<span class="fc" id="L674">        ASTExpression node = term();</span>

        //while there is an additive op
<span class="fc bfc" id="L677" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.ADDITIVE_OP)</span>
        {
            //get current token
<span class="fc" id="L680">            Token token = this.currentToken;</span>
            //absorb the additive operand
<span class="fc" id="L682">            absorb(TypeToken.ADDITIVE_OP);</span>
            //create the bin expr node with term, operand and he right term
<span class="fc" id="L684">            node = new ASTBinExpression(node, token.getAttribute(), term());</span>
<span class="fc" id="L685">        }</span>

        //return node
<span class="fc" id="L688">        return node;</span>

    }

    /**
     * Method for if statement
     * 'if '(' &lt;EXPRESSION&gt; ')' &lt;BLOCK&gt; [ 'else' &lt;BLOCK&gt; ]
     * @return an if node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTIf ifStatement() throws IOException, InvalidSyntaxException{
        //absorb if
<span class="fc" id="L701">        absorb(TypeToken.IF);</span>
        //absorb bracket open
<span class="fc" id="L703">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get expression
<span class="fc" id="L705">        ASTExpression expression = expression();</span>
        //absorb bracket close
<span class="fc" id="L707">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L709">        ASTBlock block = block();</span>

        //init block for else
        ASTBlock elseBlock;
        //if the current token is else, there is an else block
<span class="fc bfc" id="L714" title="All 2 branches covered.">        if(currentToken.getType() == TypeToken.ELSE)</span>
        {
            //absorb else
<span class="fc" id="L717">            absorb(TypeToken.ELSE);</span>
            //get else block
<span class="fc" id="L719">            elseBlock = block();</span>
        }
        //else leave the else block empty
        else
<span class="fc" id="L723">            elseBlock = new ASTBlock();</span>

        //return if node with expression, block and elseblock
<span class="fc" id="L726">        return new ASTIf(expression, block, elseBlock);</span>
    }

    /**
     * Method for for statement
     * 'for' '(' [&lt;VARIABLEDECL&gt;] ';' &lt;EXPRESSION&gt; ';' [&lt;ASSIGNMENT&gt;] ')' &lt;BLOCK&gt;
     * @return for node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTFor forStatement() throws IOException, InvalidSyntaxException{
        //absorb for
<span class="fc" id="L738">        absorb(TypeToken.FOR);</span>
        //absorb bracket open
<span class="fc" id="L740">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get declaration
<span class="fc" id="L742">        ASTDecl declaration = declaration();</span>
        //absorb semi colon
<span class="fc" id="L744">        absorb(TypeToken.SEMI_COLON);</span>
        //get expression
<span class="fc" id="L746">        ASTExpression expression = expression();</span>
        //absorb semi colon
<span class="fc" id="L748">        absorb(TypeToken.SEMI_COLON);</span>
        //get assignment
<span class="fc" id="L750">        ASTAssignment assignment = assignment();</span>
        //absorb bracket close
<span class="fc" id="L752">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L754">        ASTBlock block = block();</span>

        //return for node with variable declaration, expression, assignment and block
<span class="fc" id="L757">        return new ASTFor(declaration, expression, assignment, block);</span>
    }

    /**
     * Method for while
     * 'while' '(' &lt;EXPRESSION&gt; ')' &lt;BLOCK&gt;
     * @return while node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTWhile whileStatement() throws IOException, InvalidSyntaxException{
        //absorb while
<span class="fc" id="L769">        absorb(TypeToken.WHILE);</span>
        //absorb bracket open
<span class="fc" id="L771">        absorb(TypeToken.BRACKET_OPEN);</span>
        //get expression
<span class="fc" id="L773">        ASTExpression expression = expression();</span>
        //absorb bracket close
<span class="fc" id="L775">        absorb(TypeToken.BRACKET_CLOSE);</span>
        //get block
<span class="fc" id="L777">        ASTBlock block = block();</span>

        //return new while node with expression and block
<span class="fc" id="L780">        return new ASTWhile(expression, block);</span>
    }

    /**
     * Method for expression
     * &lt;SIMPLEEXPR&gt; { &lt;RELATIONALOP(&lt;, &gt;, ==, &lt;&gt;, &lt;=, &gt;=)&gt; &lt;SIMPLEEXPR&gt;}
     * @return expression node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTExpression expression() throws IOException, InvalidSyntaxException{
        //get simple expression
<span class="fc" id="L792">        ASTExpression node = simpleExpression();</span>

        //while there is a relational op
<span class="fc bfc" id="L795" title="All 2 branches covered.">        while(this.currentToken.getType() == TypeToken.RELATIONAL_OP)</span>
        {
            //get current token
<span class="fc" id="L798">            Token token = this.currentToken;</span>
            //absorb the operand
<span class="fc" id="L800">            absorb(TypeToken.RELATIONAL_OP);</span>

            //set node to binary expression node with left simple expression, operand and right simple expression
<span class="fc" id="L803">            node = new ASTBinExpression(node, token.getAttribute(), simpleExpression());</span>
<span class="fc" id="L804">        }</span>

<span class="fc" id="L806">        return node;</span>
    }

    /**
     * Method for statement
     * &lt;VARIABLEDECL&gt; ';' | &lt;ASSIGNMENT&gt; ';' | &lt;PRINTSTMNT&gt; ';' | &lt;IFSTMNT&gt;  | &lt;FORSTMNT&gt; | &lt;WHILESTMNT&gt;  | &lt;RETURNSTMNT&gt; ';' |
     * &lt;FUNCTIONDECL&gt; | &lt;BLOCK&gt;
     * @return a statment node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    private ASTStatement statement() throws IOException, InvalidSyntaxException{
        //get current token
<span class="fc" id="L819">        Token token = this.currentToken;</span>
        //init node to return
<span class="fc" id="L821">        ASTStatement toReturn = null;</span>

        //get type
<span class="fc bfc" id="L824" title="All 10 branches covered.">        switch(token.getType())</span>
        {
            //variable declaration
            case LET:
            {

                //get variable declaration
<span class="fc" id="L831">                toReturn = declaration();</span>
                //absorb semi colon
<span class="fc" id="L833">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L834">            };break;</span>
            case IDENTIFIER:
            {
                //get assignment
<span class="fc" id="L838">                toReturn = assignment();</span>
                //absorb semi colon
<span class="fc" id="L840">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L841">            };break;</span>
            case PRINT:
            {
                //get print
<span class="fc" id="L845">                toReturn = printStatement();</span>
                //absorb semi colon
<span class="fc" id="L847">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L848">            };break;</span>
<span class="fc" id="L849">            case IF: return ifStatement();</span>
<span class="fc" id="L850">            case FOR: return forStatement();</span>
<span class="fc" id="L851">            case WHILE: return whileStatement();</span>
            case RETURN:
            {
                //get return statment
<span class="fc" id="L855">                toReturn = returnStatement();</span>
                //absorb semi colon
<span class="fc" id="L857">                absorb(TypeToken.SEMI_COLON);</span>
<span class="fc" id="L858">            };break;</span>
<span class="fc" id="L859">            case FF: return functionDeclaration();</span>
<span class="fc" id="L860">            case CURLY_OPEN: return block();</span>
<span class="fc" id="L861">            default: return null;//EOF</span>
        }

        //return statement set
<span class="fc" id="L865">        return toReturn;</span>
    }

    /**
     * Method for block
     * '{' {&lt;STATEMENT&gt;} '}'
     * @return a block node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTBlock block() throws IOException, InvalidSyntaxException{
        //absorb open curly
<span class="fc" id="L877">        absorb(TypeToken.CURLY_OPEN);</span>
        //init list to store statements
<span class="fc" id="L879">        ArrayList&lt;ASTStatement&gt; statements = new ArrayList&lt;ASTStatement&gt;();</span>

        //while it is not an ending curly bracket
<span class="fc bfc" id="L882" title="All 2 branches covered.">        while(this.currentToken.getType() != TypeToken.CURLY_CLOSE)</span>
        {
            //get statement and add to the list
<span class="fc" id="L885">            ASTStatement statement = statement();</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">            if(statement == null)</span>
<span class="fc" id="L887">                break;</span>
<span class="fc" id="L888">            statements.add(statement);</span>
<span class="fc" id="L889">        }</span>

        //absorb closing curly bracket
<span class="fc" id="L892">        absorb(TypeToken.CURLY_CLOSE);</span>

        //return block node with list of statments
<span class="fc" id="L895">        return new ASTBlock(statements);</span>
    }

    /**
     * Method for program
     * { &lt;STATEMENT&gt; }
     * @return return node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTProgram program() throws IOException, InvalidSyntaxException{
        //init list to store statements
<span class="fc" id="L907">        ArrayList&lt;ASTStatement&gt; statements = new ArrayList&lt;ASTStatement&gt;();</span>
        //get statement
<span class="fc" id="L909">        ASTStatement statement = statement();</span>

        //while statement is not null
<span class="fc bfc" id="L912" title="All 2 branches covered.">        while(statement != null)</span>
        {
            //add statement to list and get the next one
<span class="fc" id="L915">            statements.add(statement);</span>
<span class="fc" id="L916">            statement = statement();</span>
        }

        //return new program node with statements
<span class="fc" id="L920">        return new ASTProgram(statements);</span>
    }


    /**
     * Method to start parsing
     * @return a program node
     * @throws IOException
     * @throws InvalidSyntaxException
     */
    public ASTProgram parse() throws IOException, InvalidSyntaxException{
<span class="fc" id="L931">        return program();</span>
    }

    /**
     * Method to get enum type from string
     * @param type in string
     * @return type in enum
     */
    public static Type getTypeEnum(String type)
    {
        //set type
<span class="fc bfc" id="L942" title="All 5 branches covered.">        switch(type)</span>
        {
<span class="fc" id="L944">            case &quot;int&quot; : return Type.INT;</span>
<span class="fc" id="L945">            case &quot;float&quot; : return Type.FLOAT;</span>
<span class="fc" id="L946">            case &quot;bool&quot; : return Type.BOOL;</span>
<span class="fc" id="L947">            case &quot;char&quot; : return Type.CHAR;</span>
<span class="fc" id="L948">            default : return Type.AUTO;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>